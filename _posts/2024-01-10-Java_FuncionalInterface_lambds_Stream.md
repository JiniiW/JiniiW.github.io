---
title: "[JAVA] 함수형 프로그래밍을 위한 람다와 스트림"
excerpt: "Rambda & Stream"

categories:
  - Java
tags:
  - [stream, rambda, interface]

permalink: 2024-01-10-Java_FuncionalInterface_lambds_Stream

toc: true
toc_sticky: true

date: 2024-01-10
last_modified_at: 2024-01-10
---
## Intro
함수형 프로그래밍 방식의 개념을 적용해서 코드를 작성할 때 헷갈리는 부분이 많아서 정리한다.

자바에서는 함수형 프로그래밍 방식의 코드를 작성할 때 보통 람다와 스트림의 방식을 많이 사용한는데 이 각각의 방식을 이해하고 같이 활용해보고자 한다.

흔히들 람다는 화살표를 이용한 익명함수, 스트림은 데이터 처리의 추상화라고 한다.

자세한 부분에 대해서는 앞으로 설명하겠다.

---

# 함수형 프로그래밍 
먼저 함수형 프로그랭은 말 그대로 데이터를 함수의 형태로 처리한다는 의미이다.

그럼 함수가 무엇인가?<br>
>함수는 어떠한 입력을 받아서 출력을 하는 일종의 계산 규칙이다.

**자바에서는 클래스 내에 정의된 함수를 메서드라 한다.**

앞으로 람다와 스트림을 사용할때 함수의 정의를 생각하며 코드를 작성하면 좀 더 이해하기 편할 것이다.

그러면 함수형 프로그래밍을 표현할 수 있는 람다와 스트림에 대해 알아보자.

<br>

## 1. 람다(lambda)

람다는 람다 표현식을 가르키는 용어로 함수형 프로그래밍의 종류 중 하나이다.

간단하게 말하면 기존의 메서드를 하나의 식으료 표현한 것이다.

이러한 람다 표현식은 이름이 없는 함수이기 때문에 '익명 함수'라 불린다.

코드를 통해 보자.

일반적인 메서드(함수)를 정의하면 아래와 같이 add라는 이름을 작성해줘야 한다.
```java
int add(int a, int b){
  return a + b;
}
```

하지만 람다 표현식을 보면 명시적인 이름 없이 정의가 가능하다.

```java
(a, b) -> a + b
```

이렇게 함수가 이름 없이 정의되기 때문에 '익명 함수'라 하는 것이다.<br>
이러한 특징으로 람다 표현식을 변수에 할당하거나 다른 함수에 전달하는 것이 가능하다.

정리해보면 함수형 프로그래밍에서는 일반적으로 함수를 정의하고 호출하는 방식이 아니라, 함수를 값으로 취급하고 다른 함수에 전달하는 방식을 사용한다.

> **함수를 값으로 취급하는 것이 함수형 프로그래밍의 핵심 개념 중 하나이며**, 이는 람다 표현식이 익명 함수로서 변수에 할당되거나 다른 함수에 전달될 수 있게 하는 중요한 특성이다.

이러한 람다 표현식은 함수형 인터페이스를 구현하는데 활용된다.

### 결론

람다 표현식은 익명 함수로 변수에 할당하거나 다른 함수에 전달할 수 있어 함수형 프로그래밍의 핵심이다.

<br>

## 2. 함수형 인터페이스

함수형 인터페이스는 함수형 프로그래밍을 지원하기 위해 도입되었다.

함수형 인터페이스의 가장 큰 특징은 **<mark>단 하나의 추상 메서드</mark>**를 가진 인터페이스라는 것이다.

때문에 SAM형식을 유지하는데 도움이 된다.

> SAM : Single Abstract Method 싱글 추상 메서드

SAM형식을 유지한다는 것은 람다 표현식이나 메서드 레퍼런스를 통해 인터페이스를 간결하게 구현한다는 의미이다.


코드로 살펴보자

```java
public class LambdaEx2 {

    //사용자 정의 함수형 인터페이스 정의
    @FunctionalInterface
    interface MathOperation{
        int calculation(int a, int b);
    }
    public static void main(String[] args) {

        //인터페이스 구현 및 메서드 재정의
        MathOperation addition = (a, b) -> a+b;

        int result = addition.calculation(5,3);
        System.out.println("Result : " + result);
    }
}
```

MathOperation의 인터페이스를 main에서 객체를 구현함과 동시에 `(a, b) -> a+b`의 람다 표현식을 통해 calculation 메서드를 재정의 했다.

>람다 표현식이 익명 함수이며 추상 메서드와 매개변수 타입, 개수, 반환값이 일치하기 사용 가능한 것이다.

정리하자면 람다 표현식은 하나의 추상 메서드를 가진 함수형 인터페이스에 사용 가능한 것이다.

때문에 **여러개의 추상 메서드를 가진 인터페이스는 람다 표현식을 사용할 수 없다.**

자세히 설명하자면 람다 표현식을 사용하면 컴파일러가 해당 인터페이스의 추상 메서드와 매칭을 시키는데, 여러개의 추상메서드를 가진 경우 어느 메서드에 매칭을 시켜야 할지 판단하기 어려워서 정확한 매칭이 이루어지지 않아 컴파일 오류가 발생한다.

함수형 프로그래밍의 핵심은 간결하고 명확한 코드이며, 인터페이스의 SAM 형식은 이를 달성하기 위한 것 중 하나이므로 이를 충족하지 못할 시 람다 표현식은 사용할 수 없다.
{: .notice}


**람다 표현식의 특징을 잊어먹지 말자!**
- 람다 표현식은 익명 함수이다.
- 람다 표현식으로 함수형 인터페이스의 간편한 인스턴스 생성 및 구현 정의가 가능하다.


이러한 함수형 인터페이스는 사용자가 새로 만들 수 있고 기존에 SAM형식으로 존재하는 인터페이스를 사용할 수 있다.

### 기존 인터페이스

java.util.function 패키지에 자주 쓰이는 메서드는 함수형 인터페이스로 미리 정의되어 있다.

기존에 존재하는 인터페이스를 활용한다면 메서드의 이름도 통일되고 재사용성이나 유지보수 측면에서도 좋다.

아래 표는 가장 많이 사용하는 메서드의 인터페이스중 일부이다.

|함수형 인터페이스|구현 메서드|설명|
|:---|:---:|:---:|
|Supplier&lt;T&gt;|T **get**()|매개변수 X, 반환값 O|
|Consumer&lt;T&gt;|void **accept**(T t)|매개변수 O, 반환값 X|
|Function<T,R>|R **apply**(T t)|하나의 매개변수, 결과 반환|
|Predicate&lt;T&gt;|boolean **test**(T t)|하나의 매개변수, 반환값 타입 Boolean|

각각의 인터페이스를 사용하게 되면 메서드를 반드시 재정의하여 사용해야한다.

### 결론
함수형 인터페이스는 람다 표현식을 통해 간편하게 구현 가능하며 기존 인터페이스를 사용하면 표준 메서드의 통일성과 재사용성을 얻을 수 있다.

<br>
함수형 프로그래밍에서 람다와 함수형 인터페이스는 핵심적인 개념이다.<br>
이제 이러한 개념을 기반으로 자바의 Stream API를 활용하여 데이터를 처리할 수 있다.

<br>

## 3.스트림(stream)

스트림이 등장하기전 기존의 컬렉션을 사용하는 방식은 데이터를 어떻게 변형하고 처리하는지 직접 명시해야 하는 '명령형'이였다.

하지만 스트림이 등장하면서 세부적인 조작을 직접 구현하는 대신 원하는 결과를 먼저 선언하는 '선언적' 데이터 처리가 가능해졌다.

>간단히 말하면 기존(명령형) 프로그래밍 방식은 '어떻게'하는지를 직접 구현한것이고 **스트림은 '무엇을'원하는지**를 선언하는 방식인것이다.

이 문장들이 한번에 이해되지 않을 수 있다.

예를 들어 기존에는 정렬을 위해 특정 메서드(`Collections.sort`나 `Arrays.sort`)를 호출하고 구현했다.

하지만 스트림을 사용하면 정렬에대한 선언적인 요구사항을 나타낼 수 있다.
쉽게 설명하자면 스트림에서 `sorted()`메서들 호출하여 선언을 하면, 실제 정렬의 구현은 라이브러리에 의해 처리되기 때문에 데이터 소스에 따라 정렬에 사용되는 메서드를 직접 선택하거나 구현할 필요가 없는 것이다.

>즉 스트림은 함수형 프로그래밍의 '선언적 프로그래밍' 특징을 나타낸 것이다.



함수형 프로그래밍에서 Stream API를 사용하면 각 데이터 소스의 특성에 맞게 동일한 연산을 사용할 수 있다.

그러면 이제 Stream API에 대해 알아보자.
### Stream API

>Stream API를 사용하려면 기존의 데이터 소스를 스트림으로 변환하거나 직접 스트림 객체를 생성해야 한다.

일반적으로 Stream 객체는 주로 컬렉션에서 생성되며, 컬렉션의 데이터를 다루기 위해 사용된다.

그럼 이제 데이터 소스를 스트림으로 변환하는 방법에 대해 대표적인것만 정리해보자.
#### 스트림 변환

##### 1. 컬렉션

첫 번째는 컬렉션을 스트림을 얻는 방법이다.
```java
List<String> list = Arrays.asList("one", "two", "three");
Stream<String> streamFormat = list.stream();
```
stream()은 컬렉션의 최고 조상인 Coolection에 정의되어 있다.
그래서 List와 Set을 구현한 컬렉션 클래스들은 모두 stream()메서드로 스트림을 생성할 수 있다.

##### 2. 배열

두 번째는 배열로부터 스트림을 얻는 방법이다.
```java
String[] array = {"one", "two", "three"};
Stream<String> streamFormat = Arrays.stream(array);
```
##### 3. 숫자범위

세 번째는 숫자 범위로부터 스트림 얻기 이다.
```java
IntStream intStream = IntStream.range(1, 5) //1~4까지 정수 스트림
```

만약 경계값도 포함시켜주고 싶으면 `rangeClosed()`를 사용하면 된다.

##### 4. 파일

네 번째는 파일로부터 스트림 얻기 이다.
```java
Path path = Paths.get("testName.txt");
Stream<String> streamFromFile = Files.lines(path);
```
<br>
>이러한 방식으로 데이터 소스에서 스트림을 얻은 후에는 **필터링(filtering), 매핑(mapping), 정렬(sorting), 집계(Aggregation)**등의 스트림 연산이 가능하다.

Stream API를 이용한 연산의 예제는 <a href="{{url}}/2024-01-10-Java_Stream_API"><span style = "color : red">여기서</span></a> 볼 수 있다.

### 결론
스트림 API는 기존의 명령형 프로그래밍 방식 대신 선언적 데이터 처리를 제공해 가독성과 효율성을 높일 수 있다.
다양한 데이터 소스를 스트림으로 변환하면 프로그래밍 접근에 더 유연해지고 코드의 간결성이 증가함을 알 수 있다.
데이터를 효율적으로 처리할 수 있다는 점도 강점 중 하나입니다.

---

## Outro
함수형 프로그램, 람다 표현식, 함수형 인터페이스 각각의 개념을 개별적으로 알고 있었을 때는 코드를 작성할 때 왜 이런 방식으로 해야하는지 이해하기가 어려웠다.

그런데 이러한 각 개념을 하나의 틀안에서 연관성을 생각하고 통합적으로 이해하니 코드를 작성할 때 어떤 방식으로 접근해야 하는지 깨닫게 되었다.

람다 표현식과 함수형 인터페이스를 사용함으로써 코드를 간결하게 작성할 수 있고 기존에 생각도 못했던 함수형 프로그래밍의 목적인 '무엇을'에 중점으로 두어 앞으로 코드를 작성할 때 목적을 이해하고 가독성 있는 코드를 작성해야 겠다.

또한 다양한 종류의 stream API를 상황에 따라 적절하게 사용하는 연습을 통해 함수형 프로그래밍의 특징을 잘 활용해야 겠다.