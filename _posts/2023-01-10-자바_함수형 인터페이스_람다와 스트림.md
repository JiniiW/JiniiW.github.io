---
title: "[JAVA] 함수형 프로그래밍을 위한 람다와 스트림"
excerpt: "Rambda & Stream"

categories:
  - Java
tags:
  - [java]

permalink: /java/2023-12-30-JAVA_Rambda&Stream/

toc: true
toc_sticky: true

date: 2024-01-10
last_modified_at: 2024-01-10
---
## Intro
함수형 프로그래밍 방식의 개념을 적용해서 코드를 작성할 때 헷갈리는 부분이 많아서 정리한다.

자바에서는 함수형 프로그래밍 방식의 코드를 작성할 때 보통 람다와 스트림의 방식을 많이 사용한는데 이 각각의 방식을 이해하고 같이 활용해보고자 한다.

흔히들 람다는 화살표를 이용한 익명함수, 스트림은 데이터 처리의 추상화라고 한다.

자세한 부분에 대해서는 앞으로 설명하겠다.

---

# 함수형 프로그래밍 
먼저 함수형 프로그랭은 말 그대로 데이터를 함수의 형태로 처리한다는 의미이다.

그럼 함수가 무엇인가?<br>
>함수는 어떠한 입력을 받아서 출력을 하는 일종의 계산 규칙이다.

**자바에서는 클래스 내에 정의된 메서드를 함수라 한다.**

앞으로 람다와 스트림을 사용할때 함수의 정의를 생각하며 코드를 작성하면 좀 더 이해하기 편할 것이다.

그러면 함수형 프로그래밍을 표현할 수 있는 람다와 스트림에 대해 알아보자.

<br>

## 1. 람다(lambda)

람다는 람다 표현식을 가르키는 용어로 함수형 프로그래밍의 종류 중 하나이다.

이러한 람다 표현식은 이름이 없는 함수이기 때문에 '익명 함수'라 불린다.

코드를 통해 보자.

일반적인 메서드(함수)를 정의하면 아래와 같이 add라는 이름을 작성해줘야 한다.
```java
int add(int a, int b){
  return a + b;
}
```

하지만 람다 표현식을 보면 명시적인 이름 없이 정의가 가능하다.

```java
(a, b) -> a + b
```

이렇게 함수가 이름 없이 정의되기 때문에 '익명 함수'라 하는 것이다.<br>
이러한 특징으로 람다 표현식을 변수에 할당하거나 다른 함수에 전달하는 것이 가능하다.

정리해보면 함수형 프로그래밍에서는 일반적으로 함수를 정의하고 호출하는 방식이 아니라, 함수를 값으로 취급하고 다른 함수에 전달하는 방식을 사용한다.

> **함수를 값으로 취급하는 것이 함수형 프로그래밍의 핵심 개념 중 하나이며**, 이는 람다 표현식이 익명 함수로서 변수에 할당되거나 다른 함수에 전달될 수 있게 하는 중요한 특성이다.

이러한 람다 표현식은 함수형 인터페이스를 구현하는데 활용된다.

### 결론

람다 표현식은 익명 함수로 변수에 할당하거나 다른 함수에 전달할 수 있어 함수형 프로그래밍의 핵심이다.

<br>

## 2. 함수형 인터페이스

함수형 인터페이스는 함수형 프로그래밍을 지원하기 위해 도입되었다.

함수형 인터페이스의 가장 큰 특징은 **<mark>단 하나의 추상 메서드</mark>**를 가진 인터페이스라는 것이다.

때문에 SAM형식을 유지하는데 도움이 된다.

> SAM : Single Abstract Method 싱글 추상 메서드

SAM형식을 유지한다는 것은 람다 표현식이나 메서드 레퍼런스를 통해 인터페이스를 간결하게 구현한다는 의미이다.

그렇다면 인터페이스를 구현한 익명 객체를 어떻게 람다식으로 대체 가능한걸까?

>바로 함수형 인터페이스가 **'익명 객체'**이기 때문이다.

일반적으로 인테페이스를 인스턴스화 하고 해당 인터페이스의 메서드를 호출하면 '클래스'혹은 '이름 있는 객체'라고 한다.<br>

그러면 함수형 인터페이스와 어떤점이 다른것인가?

>바로 객체의 **구현과정** 차이이다.

일반적인 객체는 인터페이스를 구현하고 해당 객체의 메서드를 호출한다.<br>
하지만 익명객체는 인터페이스를 구현함과 동시에 해당 인터페이스의 메서드를 재정의 한다.

코드로 살펴보면

```java
public class LambdaEx2 {

    //사용자 정의 함수형 인터페이스 정의
    @FunctionalInterface
    interface MathOperation{
        int calculation(int a, int b);
    }
    public static void main(String[] args) {

        //인터페이스 구현 및 메서드 재정의
        MathOperation addition = (a, b) -> a+b;

        int result = addition.calculation(5,3);
        System.out.println("Result : " + result);
    }
}
```

MathOperation의 인터페이스를 main에서 객체를 구현함과 동시에 `(a, b) -> a+b`의 람다 표현식을 통해 calculation 메서드를 재정의 했다.

결론적으로 함수형 인터페이스의 메서드와 람다식의 매개변수의 타입, 개수 그리고 반환값이 일치하고, 람다 표현식이 익명 함수이기 때문에 메서드를 람다 표현식으로 구현이 가능하다.
<br>

**람다 표현식의 특징을 잊어먹지 말자!**
- 람다 표현식은 익명 함수이다.
- 람다 표현식으로 함수형 인터페이스의 간편한 인스턴스 생성 및 구현 정의가 가능하다.


이러한 함수형 인터페이스는 사용자가 새로 만들 수 있고 기존에 SAM형식으로 존재하는 인터페이스를 사용할 수 있다.

### 기존 인터페이스

java.util.function 패키지에 자주 쓰이는 메서드는 함수형 인터페이스로 미리 정의되어 있다.

기존에 존재하는 인터페이스를 활용한다면 메서드의 이름도 통일되고 재사용성이나 유지보수 측면에서도 좋다.

아래 표는 가장 많이 사용하는 메서드의 인터페이스중 일부이다.

|함수형 인터페이스|구현 메서드|설명|
|:---|:---:|:---:|
|Supplier&lt;T&gt;|T **get**()|매개변수 X, 반환값 O|
|Consumer&lt;T&gt;|void **accept**(T t)|매개변수 O, 반환값 X|
|Function<T,R>|R **apply**(T t)|하나의 매개변수, 결과 반환|
|Predicate&lt;T&gt;|boolean **test**(T t)|하나의 매개변수, 반환값 타입 Boolean|

각각의 인터페이스를 사용하게 되면 메서드를 반드시 재정의하여 사용해야한다.

### 결론
함수형 인터페이스는 람다 표현식을 통해 간편하게 구현 가능하며 기존 인터페이스를 사용하면 표준 메서드의 통일성과 재사용성을 얻을 수 있다.

<br>
함수형 프로그래밍에서 람다와 함수형 인터페이스는 핵심적인 개념이다.<br>
이제 이러한 개념을 기반으로 자바의 Stream API를 활용하여 데이터를 처리할 수 있다.

<br>

## 3.스트림(stream)

스트림이 등장하기전 기존의 컬렉션을 사용하는 방식은 데이터를 어떻게 변형하고 처리하는지 직접 명시해야 하는 '명령형'이였다.

하지만 스트림이 등장하면서 세부적인 조작을 직접 구현하는 대신 원하는 결과를 먼저 선언하는 '선언적' 데이터 처리가 가능해졌다.

>간단히 말하면 기존(명령형) 프로그래밍 방식은 '어떻게'하는지를 직접 구현한것이고 **스트림은 '무엇을'원하는지**를 선언하는 방식인것이다.

이 문장들이 한번에 이해되지 않을 수 있다.

예를 들어 기존에는 List를 정렬할 때는 `Collections.sort`를 사용하고, 배열을 정렬할 때는 `Arrays.sort`를 사용하는 것처럼 목적은 같지만 데이터 소스에 따라 다른 메서드를 이용했다.

이러한 불편한 점을 보완하기 위해 데이터 소스를 추상화하여 통일된 방식으로 데이터를 처리하는 것이 스트림이다.

Stream API를 사용하면 각 데이터 소스의 특성에 맞게 동일한 연산을 사용할 수 있다.

그러면 이제 Stream API에 대해 알아보자.
### Stream API

>Stream API를 사용하기 위해서는 기존의 데이터 소스를 스트림으로 변환하거나 직접 생성된 스트림을 사용할 수 있다.

데이터 소스를 스트림으로 변환하는 방법에 대해 대표적인것만 정리해보자.
#### 스트림 변환

##### 1. 컬렉션

첫 번째는 컬렉션을 스트림을 얻는 방법이다.
```java
List<String> list = Arrays.asList("one", "two", "three");
Stream<String> streamFormat = list.stream();
```
##### 2. 배열

두 번째는 배열로부터 스트림을 얻는 방법이다.
```java
String[] array = {"one", "two", "three"};
Stream<String> streamFormat = Arrays.stream(array);
```
##### 3. 숫자범위

세 번째는 숫자 범위로부터 스트림 얻기 이다.
```java
IntStream intStream = IntStream.range(1, 5) //1~4까지 정수 스트림
```

##### 4. 파일

네 번째는 파일로부터 스트림 얻기 이다.
```java
Path path = Paths.get("testName.txt");
Stream<String> streamFromFile = Files.lines(path);
```

이러한 방식으로 데이터 소스에서 스트림을 얻은 후에는 필터링(filtering), 매핑(mapping), 정렬(sorting), 집계(Aggregation)등의 스트림 연산이 가능하다.
<br>
Stream API를 이용한 연산의 예제는 여기서 볼 수 있다.

다양한 스트림 연산을 통해 우리는 스트림의 특징을 알 수 있다.
- 불변성 : 스트림은 원본 데이터를 변경하지 않고 새로운 스트림을 생성한다.
- 스트림 연산은 중간 연산과 최종 연산을 구분한다.
- 일회성 : 한 번 생성하고 사용한 스트림은 재사용할 수 없지만 스트림을 다시 생성하여 재사용 가능하다.
- 병렬화 : 내부 반복자를 통한 데이터 병렬처리가 가능하다.

### 결론
스트림 API는 기존의 명령형 프로그래밍 방식 대신 선언적 데이터 처리를 제공해 가독성과 효율성을 높일 수 있다.
다양한 데이터 소스를 스트림으로 변환하면 프로그래밍 접근에 더 유연해지고 코드의 간결성이 증가함을 알 수 있다.
데이터를 효율적으로 처리할 수 있다는 점도 강점 중 하나입니다.

---

## Outro

함수형 프로그래밍의 핵심인 람다와 함수형 인터페이스, 그리고 스트림의 활용법을 명확하게 이해할 수 있었다.
이러한 개념들은 코드의 간결성과 가독성을 향샹시키기 때문에 자바에서 많이 활용되는 이유를 깨달았다.